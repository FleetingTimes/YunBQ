# 详细的知识总结（端到端流程与示例版）

本文面向研发与运维，系统总结整个项目的技术架构、每个功能的端到端流程（前端→后端→数据层→缓存/日志/安全），并在关键环节插入示例代码片段与详细注释，帮助团队快速理解并安全迭代。

— 聚焦“怎么跑起来、链路怎么走、哪里可观测” —

## 架构速览（与代码实现对齐）
- 前端（Vite + Vue + Axios）
  - API 基址：优先 `VITE_API_BASE`；若未配置且当前页面为公网域名（HTTPS，`*.shiyan.online`），自动回退到 `https://api.<域名>/api`，确保移动端公网访问可直连后端。
  - 统一拦截器：请求自动附加 `Authorization`；响应拦截 401 清理登录态并跳转登录页。
- 后端（Spring Boot + MyBatis + Spring Cache）
  - 默认 Caffeine 本地缓存；激活 `redis` Profile 后使用 Redis，读路径 `@Cacheable`、写路径 `@CacheEvict` 主动失效命名空间。
  - 请求日志过滤器：生成 `requestId`、解析客户端 IP（支持 `X-Forwarded-For`/`CF-Connecting-IP`/`X-Real-IP`）、记录状态码与耗时，异步持久化。
- 数据与基础设施
  - MySQL：业务表与审计/请求/认证/错误日志表。
  - Nginx/CDN：作为入口代理并透传真实客户端 IP 头部。

## 端到端流程示例

### 导航页加载与缓存命中（站点按分类）
- 前端触发：进入导航页 → 计算 `API_BASE` → 发起 `GET /api/navigation/sites/category/{categoryId}`。
- 后端链路：Controller → Service → `@Cacheable` 命中则返回；未命中则查库并回写缓存。
- 命名空间与 TTL：在 Redis Profile 下，`sites_by_category` 建议 TTL 60s（示例）；未配置的默认 60s。

示例代码（带详细注释）
```java
// 说明：读取某分类下站点列表；命中缓存则绕过数据库，提高列表页响应速度。
// 注意：缓存 key 使用入参 categoryId，确保不同分类的数据隔离。
@Cacheable(cacheNames = "sites_by_category", key = "#categoryId")
public List<SiteDTO> listSitesByCategory(Long categoryId) {
    // 实际实现通过 Mapper 访问数据库并排序（权重/点击量等）
    // 此处省略持久层细节，仅强调缓存包裹的读路径粒度
    return siteMapper.selectByCategory(categoryId);
}
```

### 登录鉴权与前端拦截器
- 登录成功：保存 Token（localStorage/状态管理）；后续请求自动附加 `Authorization: Bearer <token>`。
- 401 处理：清理登录态并跳转登录页，防止用户处于“半失效”状态。

Axios 关键片段（带详细注释）
```js
// 说明：在每个请求中自动注入 Authorization 头；统一处理 401 未授权错误。
instance.interceptors.request.use((config) => {
  const token = authStore.getToken(); // 从状态或 localStorage 获取当前用户的 JWT
  if (token) {
    config.headers.Authorization = `Bearer ${token}`; // 服务端据此解析用户身份
  }
  return config;
});

instance.interceptors.response.use(
  (resp) => resp,
  (error) => {
    if (error?.response?.status === 401) {
      authStore.clear();         // 清理本地登录态，避免后续请求持续失败
      router.replace('/login');  // 跳转登录页并可附加来源路由参数
    }
    return Promise.reject(error);
  }
);
```

### 请求日志与客户端 IP 解析
- 过滤器职责：贯穿每个请求，生成 `requestId`、解析客户端 IP、记录方法/URI/状态码/耗时/UA/用户 ID，并按采样异步写库。
- IP 解析顺序：`X-Forwarded-For`（首个有效地址）→ `CF-Connecting-IP` → `X-Real-IP` → `request.getRemoteAddr()`。

关键方法（带详细注释）
```java
// 说明：解析真实客户端 IP，兼容多层代理与 CDN；避免记录到最近一跳代理 IP。
private String clientIp(HttpServletRequest request) {
    // 1) 标准与常见代理头；XFF 可能包含逗号分隔的多 IP 列表
    String xff = request.getHeader("X-Forwarded-For");
    if (xff != null && !xff.isBlank()) {
        for (String part : xff.split(",")) { // 取最左边第一个非 unknown 的地址
            String ip = part.trim();
            if (!ip.isEmpty() && !"unknown".equalsIgnoreCase(ip)) {
                return ip;
            }
        }
    }
    // 2) Cloudflare 透传头（单值）
    String cf = request.getHeader("CF-Connecting-IP");
    if (cf != null && !cf.isBlank()) return cf.trim();
    // 3) Nginx/反代常用头
    String real = request.getHeader("X-Real-IP");
    if (real != null && !real.isBlank()) return real.trim();
    // 4) 回退：容器层获取的对端地址（可能是最近一跳代理）
    return request.getRemoteAddr();
}
```

## 运维核查与排查手册（速查）
- Redis：`TTL sites_by_category::<categoryId>` 观察命中与存活时间；`SCAN 0 MATCH sites_by_category*` 查看键分布。
- 日志：按 `requestId` 在请求/错误日志中串联前后端；采样率由 `logdb.request-sampling-percent` 控制。
- 代理：确保透传 `X-Forwarded-For`/`CF-Connecting-IP`/`X-Real-IP`，否则后端可能仅记录代理 IP。
- CORS 与域：后端允许来源需与前端域一致（协议/端口），前端未设 `VITE_API_BASE` 时公网自动回退。

## 关键文件索引
- 后端：`RequestLoggingFilter.java`（请求日志与 IP 解析）、`LogService.java`/`LogProperties.java`（异步与采样）、`*Service.java`（`@Cacheable`/`@CacheEvict`）。
- 配置：`application.yml` 与 `application-redis.yml`（缓存与日志开关/TTL）。
- 前端：`src/api/http.js`（API 基址推导与拦截器）。

## 1. 总览与技术选型
- 项目定位：拾言（短内容/便签）与导航广场融合平台，包含消息中心、账户与管理后台。
- 技术栈：
  - 后端：Spring Boot、Spring Security（JWT）、MyBatis-Plus（分页/查询）、Lombok。
  - 前端：Vue 3（组合式 API）、Element Plus、Vite。
  - 数据库：MySQL（业务表 + 审计/请求/认证/错误日志表）。
  - 缓存：Redis（仅用于“热门/最近公开拾言”，当前可整体禁用）。
- 分层架构：Controller（接口）→ Service（业务）→ Mapper（数据访问）→ DB（MySQL）。
- 部署：Docker Compose（可选 Nginx 反向代理）；静态头像目录 `uploads/avatars` 映射 `/uploads/**`。

## 2. 核心领域模型与数据表（摘要）
- 用户（users）：`id/username/email(unique)/role/avatar_url/signature/color/...`
- 拾言（notes）：`id/user_id/content/tags/is_public/archived/likes/favorites/created_at/updated_at`
- 收藏（favorites）：`id/note_id/user_id`（唯一组合索引避免重复收藏）
- 导航分类（navigation_categories）：`id/name/parent_id/enabled/sort`
- 导航站点（navigation_sites）：`id/category_id/name/url/intro/tags/clicks/sort_weight`
- 日志表：`request_logs/auth_logs/error_logs/audit_logs`（保留与清理）

## 3. 功能与技术流程

### 3.1 拾言（便签）
- 前端视图与交互：
  - `Notes.vue` + `notes/NotesBody.vue`：创建/编辑/列表分页、公开/私有切换、标签展示。
  - 列表页普遍采用骨架/空态/错误态三态渲染，移动端滚动哨兵触底加载。
- 后端接口（`NoteController`）：
  - `GET /api/notes`（分页/过滤：`q/isPublic/mineOnly/archived/page/size`）
  - `POST /api/notes`（创建）/ `PUT /api/notes/{id}`（更新）/ `DELETE /api/notes/{id}`（删除）
  - `POST /api/notes/{id}/like` / `DELETE /api/notes/{id}/like`
  - `POST /api/notes/{id}/favorite` / `DELETE /api/notes/{id}/favorite`
  - `GET /api/notes/{id}/favorites`（总数与“我是否收藏”）
- 端到端流程（以“创建/更新拾言”为例）：
  1) 前端表单提交（内容/公开性/标签），校验通过后调用接口；
  2) Controller 解包请求体，注入当前用户ID（JWT）；
  3) Service 校验作者身份与业务约束，解析正文中的 `#tag`，归一化保存到 `tags` 字段；
  4) Mapper 执行插入/更新 SQL；
  5) 生成交互消息（如更新后通知自身或相关用户）；
  6) 若启用热门/最近缓存：触发相关键失效；
  7) 返回统一响应，前端根据状态刷新列表并展示反馈。
- 示例（伪代码，含详细注释）：
```java
// NoteController.java（示例，仅示意结构）
@PostMapping("/api/notes")
public ResponseEntity<NoteDto> create(@RequestBody CreateNoteRequest req) {
    Long currentUserId = AuthUtil.currentUserId(); // 从 JWT 注入的安全上下文获取用户ID
    // 委托服务层处理业务逻辑，包括校验、标签解析、DB 写入与缓存失效
    NoteDto dto = noteService.create(currentUserId, req);
    return ResponseEntity.ok(dto);
}

// NoteService.java（示例）
public NoteDto create(Long userId, CreateNoteRequest req) {
    // 1. 参数校验：长度/空值/公开性（私有内容不外显）
    validateCreate(req);
    // 2. 标签解析：从正文提取 #tag，去重、归一化后保存至 tags 字段
    List<String> tags = tagParser.extract(req.getContent());
    // 3. 构建实体并持久化
    Note entity = new Note(userId, req.getContent(), tagsToString(tags), req.isPublic());
    noteMapper.insert(entity);
    // 4. 行为消息：可选，记录“创建拾言”用于消息中心或审计
    messageService.onNoteCreated(userId, entity.getId());
    // 5. 缓存失效：若启用热门/最近缓存，失效相关键空间以确保一致性
    if (noteCacheService.isEnabled()) {
        noteCacheService.evictHotAll();
        noteCacheService.evictRecentAll();
    }
    return NoteDto.from(entity);
}
```
- 点赞/收藏流程要点：
  - 接口限制：公开拾言全站可互动；私有仅作者可操作（或禁止）。
  - 幂等性：重复点赞/收藏需判定并避免计数错误；收藏用组合唯一索引约束。
  - 消息生成：被点赞/收藏的作者收到对应消息，更新未读计数。

### 3.2 导航广场
- 前端：`Square.vue` + `square/SquareBody.vue`，左侧分类树与右侧站点卡片列表联动，分页加载与标签过滤；移动端优化触底加载。
- 后端接口（`NavigationController`）：
  - `GET /api/navigation/categories`（根分类/全部启用分类）
  - `GET /api/navigation/sites/category/{categoryId}`（按分类分页）
  - `GET /api/navigation/sites/tags/{tags}`（逗号分隔标签，`LIKE` 模糊匹配）
- 数据访问：`NavigationSiteMapper` 提供按分类/标签/排序的查询，精选/热门通过权重字段与点击量排序实现。

### 3.3 消息中心
- 前端：`Messages.vue` 列表分页，支持已读、删除与未读计数显示。
- 后端接口（`MessageController`）：
  - `GET /api/messages`（分页，`type` 过滤）
  - `POST /api/messages/{id}/read`（标记已读）
  - `DELETE /api/messages/{id}`（删除）
  - `GET /api/messages/counts`（未读计数）
- 生成时机：
  - 互动行为（点赞/收藏）、系统通知（密码重置、审核通过/驳回）等由服务层调用 `MessageService` 生成对应消息；
  - 读取/删除更新用户维度的未读计数（避免拉取全量）。

### 3.4 账户与安全
- 前端：`Login.vue` 登录表单（含验证码），个人资料与头像上传入口（顶栏或个人中心页）。
- 后端接口：
  - `AccountController`：公开资料、当前用户信息、更新资料与头像上传。
  - `CaptchaController`：验证码获取与校验。
  - `PasswordResetController`：找回密码（邮件重置码）与重置密码。
- 技术流程：
  - 登录：提交用户名/密码/验证码 → 服务层校验 → 发放 JWT → 前端保存 Token 并注入请求头；
  - 头像上传：后端保存文件至 `uploads/avatars` 并返回可访问 URL；
  - 验证码：当前进程内存储（`ConcurrentHashMap`），单实例适用；多实例建议迁移 Redis + TTL；
  - 找回密码：生成一次性重置码（带 TTL/频控），发送至邮箱，校验通过后更新密码。

### 3.5 管理后台
- 前端：`Admin.vue` 左侧菜单 + 右侧主区，包含用户管理、导航/站点管理、日志查询与导出。
- 后端：`AdminController`，路径前缀 `/api/admin/**` + 方法级 `@PreAuthorize('hasRole('ADMIN')')` 双重保护；支持批量导入/导出、审计与日志。

### 3.6 背景与辅助
- `BackgroundController`：`GET /api/background` 返回随机背景图 URL，可选宽高与关键词，前端用于沉浸式背景。
- `DebugController`：开发联调探针，生产环境建议关闭避免信息泄露。

## 4. 缓存策略与 Redis（可选）
- 组件：`NoteCacheService` 使用 `StringRedisTemplate`，键空间：
  - `notes:hot:size:{size}` → 热门公开拾言列表；
  - `notes:recent:size:{size}` → 最近公开拾言列表。
- 读取流程（示例代码，含详细注释）：
```java
// NoteService.hotPublic(size)（示例，结构化说明）
public List<NoteDto> hotPublic(int size) {
    // 1. 先尝试读取缓存（命中则直接返回）
    Optional<List<NoteDto>> cached = noteCacheService.getHot(size);
    if (cached.isPresent()) return cached.get();
    // 2. 未命中：从 DB 读取公开拾言并计算热度分（如点赞/收藏/时间衰减）
    List<Note> notes = noteMapper.selectPublicHot(size);
    List<NoteDto> dtos = scoreAndSort(notes);
    // 3. 写入缓存并设置 TTL（避免冷数据常驻）
    noteCacheService.setHot(size, dtos);
    return dtos;
}
```
- 失效策略：写操作（创建/更新/删除/点赞/收藏）后失效相关键空间，确保“热门/最近列表”一致性。
- 当前状态：若前端取消“热门/最近”页面且后端不再调用读取与失效方法，则可整体停用 Redis。
- 开关化建议：
  - 增加配置 `cache.notes.enabled=false`；
  - 注入改为可选（`@Autowired(required=false)` 或 `ObjectProvider`）；
  - 启用时读写缓存，禁用时走 DB 并不触发失效操作。

## 5. 日志、审计与清理
- 日志表：请求、认证、错误、审计日志；便于故障定位与安全审计。
- 定时清理：`LogRetentionScheduler` 依据 `logdb.retention-sweep-interval-ms` 周期清理超期日志；生产建议按业务量配置保留天数并定期归档。

## 6. 前端路由与布局
- 入口：`src/main.js` 注册 Element Plus、路由与样式；
- 根组件：`App.vue` 承载 `router-view`，统一透明页脚；
- 布局：`TwoPaneLayout.vue` 顶栏吸顶 + 左右两列，右侧滚动容器对齐不同视图；
- 通用组件与工具：
  - `AppTopBar.vue` 顶栏（搜索、入口按钮、头像/消息入口）；
  - 列表与分页组件：`NavigationSiteList.vue`、`SiteNoteList.vue`；
  - 工具：`utils/siteNoteUtils.js`（标签过滤、打开站点、内容截断）。
- 交互模式：骨架/空态/错误态统一，滚动哨兵自动加载，BackTop 回到顶部；移动端适配优先。

## 7. 安全策略与风控
- 鉴权：JWT 登录后注入 `SecurityContext`，接口读取当前用户；管理端严格角色 `ADMIN`。
- 输入校验：内容长度、标签格式、URL 合法性；防止 SQL 注入与脚本注入。
- 验证码与频控：登录/找回密码建议启用验证码；多实例使用 Redis 存储验证码与 TTL，避免重放与暴力破解。
- CORS 与 CSRF：前后端分离时限定允许来源；对有状态接口评估 CSRF 风险并采取保护。

## 8. 性能优化建议
- 数据层：为高频字段建立组合索引（如 `notes(user_id,is_public,tags)`）；分页统一上限与参数校验。
- 缓存：热门/最近禁用时避免冗余失效调用；启用时使用批量失效与模式匹配删除，避免 `keys` 全量扫描。
- 前端：列表虚拟化（长列表）、图片懒加载、错误重试与降级策略。

## 9. 测试策略与用例
- 冒烟用例：
  - 拾言：创建→编辑→公开/私有切换→点赞/收藏→删除；
  - 导航：分类树加载→站点分页→标签搜索→精选排序；
  - 消息：生成→未读计数→标记已读→删除；
  - 账户：登录→资料更新→头像上传→找回密码。
- 回归场景：公开/私有边界、分页与触底加载一致性、移动端滚动哨兵触发。
- 缓存验证：在启用 Redis 时校验读写与失效，禁用时确保不抛连接异常且逻辑正确回退至 DB。

## 10. 常见问题（FAQ）
- 取消“热门/最近”后 Redis 是否仍会被操作？
  - 若后端保留失效调用（`evictHotAll/evictRecentAll`），写操作仍会触发 Redis。建议同步移除或开关化禁用。
- 头像无法显示？
  - 检查 `/uploads/**` 静态映射与宿主机 `uploads/avatars` 目录权限与路径。
- 找回密码邮件未达？
  - 校验 SMTP 配置与频控；记录错误日志定位失败原因。

## 11. 路线图（建议）
- 缓存开关化：新增 `cache.notes.enabled` 并实现可选注入、分支逻辑。
- 验证码/密码找回迁移 Redis：增强多实例一致性与风控。
- 日志与监控：结构化日志、聚合与告警（ELK/Prometheus + Grafana）。
- 前端体验：长列表虚拟化、懒加载与 PWA；统一错误重试策略。
- CI/CD：增加自动化测试与静态检查、发布流水线。

---

如需我继续：
- 实现“Redis 缓存开关化”（含详细注释与配置文档）；或
- 迁移验证码/找回密码至 Redis（含 TTL、频控与接口联动说明），
请告知，我可以直接在后端提交改动并完善对应文档。

## 12. 逐步调用链详解（谁一步步调用谁）

本节按功能拆解端到端调用链，逐步说明“前端事件 → 前端 API → 后端 Controller → Service → Mapper/DB → 缓存/消息 → 响应 → 前端状态更新”的执行过程，并给出关键类与方法。

### 12.1 拾言：列表查询（GET /api/notes）
- 前端触发：`Notes.vue` 初始化或筛选变更 → 调用前端 API 模块 `api.notes.list({ page, size, q, archived, isPublic, mineOnly })`。
- 后端入口：`NoteController.list(...)`（路径别名 `/api/notes` 与 `/api/shiyan`）。
- 服务层：`NoteService.list(uid, page, size, q, archived, isPublic, mineOnly)`。
- 数据访问：`NoteMapper` 使用 `QueryWrapper` 组装条件（关键词、公开性、作者归属、归档），`Page.of(page,size)` 执行分页 SQL。
- 结果封装：`PageResult<NoteItem>` 组装 `items/total/page/size` 返回。
- 前端状态：列表组件根据响应更新分页与滚动哨兵；骨架/空态/错误态切换。

### 12.2 拾言：创建（POST /api/notes）
- 前端触发：`NotesBody.vue` 表单提交 → `api.notes.create(payload)`。
- 后端入口：`NoteController.create(@Valid @RequestBody NoteRequest req)`。
- 服务层：`NoteService.create(uid, req)`：
  1) 参数与权限校验（需登录、字段规范、公开性约束）；
  2) 标签解析：从 `req.content` 提取 `#tag` → 去重与归一化 → 写入 `tags` 字段；
  3) 持久化：`NoteMapper.insert(entity)`；
  4) 生成行为消息：`MessageService.onNoteCreated(uid, noteId)`（作者自我行为可选跳过）；
  5) 缓存失效（启用时）：`NoteCacheService.evictHotAll()` 与 `evictRecentAll()`；
  6) 返回 `Note`/`NoteDto`。
- 前端状态：刷新列表或插入新项、弹出成功提示、清空表单。

### 12.3 拾言：更新（PUT /api/notes/{id}）与删除（DELETE /api/notes/{id}）
- 更新入口：`NoteController.update(id, req)` → `NoteService.update(uid, id, req)`。
- 删除入口：`NoteController.delete(id)` → `NoteService.delete(uid, id)`。
- 服务层通用步骤：
  - 校验作者归属与状态（公开/归档策略）；
  - 更新：解析与覆盖字段 → `NoteMapper.updateById(note)`；
  - 删除：`NoteMapper.deleteById(id)` 并进行联表清理（如点赞/收藏）视实现而定；
  - 交互消息（可选）：更新/删除产生系统消息或审计记录；
  - 缓存失效：`evictHotAll/evictRecentAll`。
- 前端状态：更新局部卡片或移除条目，维持分页与滚动位置。

### 12.4 拾言：点赞（POST /api/notes/{id}/like / DELETE 取消）
- 前端触发：卡片上的“点赞”按钮 → `api.notes.like(id)` 或 `api.notes.unlike(id)`。
- 后端入口：`NoteController.like(id)` / `NoteController.unlike(id)`。
- 服务层：`NoteService.like(uid, id)` / `NoteService.unlike(uid, id)`：
  - 幂等与越权校验：禁止重复点赞、仅登录用户；
  - 写入：`NoteLikeMapper.insert(...)` 或删除；同步更新 `notes.likes` 计数（防并发建议使用乐观/原子操作）；
  - 行为消息：对作者生成“收到的赞”（作者给自己不生成）；
  - 缓存失效：`evictHotAll/evictRecentAll`；
  - 返回最新计数或状态。
- 前端状态：更新点赞按钮状态与计数，动画与提示。

### 12.5 拾言：收藏（POST /api/notes/{id}/favorite / DELETE 取消）与收藏信息（GET /api/notes/{id}/favorites）
- 前端触发：卡片上的“收藏”按钮与收藏信息显示。
- 后端入口：`NoteController.favorite(id)` / `NoteController.unfavorite(id)` / `NoteController.favoriteInfo(id)`。
- 服务层：`NoteService.favorite(uid, id)` / `NoteService.unfavorite(uid, id)` / `NoteService.favoriteInfo(uid, id)`：
  - 写入/删除：`NoteFavoriteMapper.insert/delete`（收藏唯一组合索引防重复）；
  - 计数更新：刷新 `favorites` 或聚合查询返回；
  - 行为消息：通知作者“被收藏”；
  - 缓存失效：写操作后失效热门/最近；
  - 收藏信息：返回 `{ total, meFavorited }` 供前端渲染。
- 前端状态：更新收藏按钮状态与计数。

### 12.6 拾言：最近/热门公开列表（GET /api/notes/recent / GET /api/notes/hot）
- 前端触发：公开页或小镇页加载 → `api.notes.recent(size)` / `api.notes.hot(size)`。
- 后端入口：`NoteController.recent(size)` / `NoteController.hot(size)`。
- 服务层：`NoteService.recentPublic(uid, size)` / `NoteService.hotPublic(uid, size)`：
  1) 先读缓存：`NoteCacheService.getRecent(size)` / `getHot(size)`；命中直接返回；
  2) 未命中：
     - 最近：`NoteMapper.selectPublicRecent(size)` 按时间排序取前 N；
     - 热门：`NoteMapper.selectPublicHot(size)` 并计算热度分（点赞/收藏/时间衰减）；
  3) 写缓存：`setRecent(size, dtos)` / `setHot(size, dtos)` 设置 TTL；
  4) 返回分页结构或列表。
- 前端状态：渲染卡片与分页；若功能取消，建议停用相关端点与缓存失效调用。

### 12.7 导航广场：分类与站点
- 前端触发：`Square.vue` 加载分类 → 点击分类或滚动触底加载站点。
- 后端入口：`NavigationController`：
  - 分类：`GET /api/navigation/categories` / `.../categories/all` → `NavigationCategoryService.list/tree`；
  - 站点：`GET /api/navigation/sites/category/{id}` → `NavigationSiteService.listByCategory(id,page,size)`；
  - 标签搜索：`GET /api/navigation/sites/tags/{tags}` → `NavigationSiteService.searchByTags(tags,page,size)`。
- 数据访问：`NavigationSiteMapper` 按分类/标签/权重/点击量排序，`Page` 分页。
- 前端状态：`NavigationSiteList.vue` 分页加载、移动端哨兵触发与 BackTop 回到顶部。

### 12.8 消息中心：列表/已读/删除/未读计数
- 前端触发：`Messages.vue` 加载列表、点击“已读”或“删除”、顶部显示未读计数。
- 后端入口：`MessageController`：
  - 列表：`GET /api/messages` → `MessageService.list(uid,page,size,type)`；
  - 已读：`POST /api/messages/{id}/read` → `MessageService.markRead(uid,id)`；
  - 删除：`DELETE /api/messages/{id}` → `MessageService.delete(uid,id)`；
  - 未读计数：`GET /api/messages/counts` → `MessageService.unreadCounts(uid)`。
- 数据访问：`MessageMapper` 分页查询、分组统计（`unreadCountsByType`）、总数计算（`unreadTotal`）。
- 前端状态：更新列表项状态与计数徽标；适配移动端分页。

### 12.9 账户与个人中心：资料与头像
- 前端触发：`Login.vue` 登录（带验证码）；个人中心加载资料与上传头像。
- 后端入口：`AccountController`：
  - 当前用户信息：`GET /api/account/me` → 读取 `AuthUtil.currentUserId()` → `UserMapper.selectById(uid)` → 过滤敏感字段 → 返回；
  - 公开资料：`GET /api/account/profile/{username}` → `UserMapper.selectOne(username)` → 返回公开字段；
  - 更新资料/头像上传：`PUT/POST /api/account/*` → 校验当前用户 → 覆盖非空字段/保存文件至 `uploads/avatars` → 返回新资料。
- 静态资源：由后端 `WebMvcConfigurer` 映射 `/uploads/**` 指向 `uploads/avatars`，前端拼接完整头像 URL。

### 12.10 验证码与找回密码
- 验证码：
  - 获取：`CaptchaController.get()` → `CaptchaService.generate()` → 返回 `{ id, image(dataUrl) }`；
  - 校验：`CaptchaController.verify()` → `CaptchaService.verify(id, code)`（一次性成功即删除或过期清理）。
- 找回密码：
  - 触发：`PasswordResetController.forgot` → `CaptchaService.verify(captchaId, captchaCode)` → 通过则 `PasswordResetService.createCode(email)` 生成一次性重置码并发送邮件 → 返回 `{ ok:true }`；
  - 重置：`PasswordResetController.reset`（存在于服务）→ 校验邮箱与重置码 → 更新密码（`PasswordEncoder.encode`）→ 返回 `{ ok:true }`。

### 12.11 管理后台
- 前端触发：`Admin.vue` 加载用户/站点/日志管理页面，进行查询与导入/导出。
- 后端入口：`AdminController`（路径前缀 `/api/admin/**`，方法级 `@PreAuthorize('hasRole('ADMIN')')`）：
  - 用户列表：`GET /api/admin/users` → `UserMapper.selectPage(QueryWrapper)`；
  - 创建/更新用户：唯一性校验（用户名/邮箱）→ `PasswordEncoder.encode` 处理明文密码 → `UserMapper.insert/updateById`；
  - 日志查询：`AuditLogMapper/RequestLogMapper/AuthLogMapper/ErrorLogMapper.selectPage`；
  - 批量导入/导出：解析 CSV → 查找/更新/创建用户与站点 → 记录错误与跳过原因。
- 前端状态：表格分页、表单校验、导入结果反馈与错误列表展示。

### 12.12 背景与辅助
- 随机背景图：`BackgroundController.get()` → 构造随机图服务 URL（带宽高与关键词）→ 返回字符串或 `{ url }` JSON → 前端设置背景。
- 调试接口：`DebugController` → 返回当前 `SecurityContext` 与请求头快照（生产关闭）。

---

以上调用链基于当前代码中的控制器与服务实现，涵盖“入口 → 业务 → 数据 → 缓存/消息 → 响应”的关键路径。若需，我可以继续为具体方法（如 `NoteService.like/favorite`、`NavigationSiteService.searchByTags`）补充更细颗粒的参数校验与异常转换说明，并在源码中添加详细注释以便维护。

## 13. 逐方法实现调用链（精细版）

本章对每个功能的每个方法进行更细粒度的“实现调用链”梳理，统一采用“Controller → Service → Mapper/缓存/消息 → 返回”结构，并列出入参、校验、事务与缓存失效点。以下清单仅包含代码库中已实现或在 Controller 注释中明确的端点/方法。

——

### 13.1 拾言（Note）方法清单

- `GET /api/notes` 列表分页
  - Controller：`NoteController.list(page,size,q,archived,isPublic,mineOnly)` → 读取 `uid=AuthUtil.currentUserId()`，记录日志。
  - Service：`NoteService.list(uid,page,size,q,archived,isPublic,mineOnly)` → 组合 `QueryWrapper` 条件，`NoteMapper.selectPage(...)`；聚合 `likeCount/favoriteCount` 与作者信息；登录态补 `likedByMe/favoritedByMe`。
  - 返回：`PageResult<NoteItem>`。

- `POST /api/notes` 创建
  - Controller：`NoteController.create(req)`（需登录）。
  - Service：`NoteService.create(userId, req)` → `parseFromContent` 标签解析与内容清理 → `NoteMapper.insert(n)` → 缓存失效 `evictHotAll/evictRecentAll` → 返回新实体。

- `PUT /api/notes/{id}` 更新
  - Controller：`NoteController.update(id, req)`（需登录）。
  - Service：`NoteService.update(userId,id,req)` → 作者校验 → 合并标签与字段 → `NoteMapper.updateById(n)` → 失效 `evictHotAll/evictRecentAll`。

- `DELETE /api/notes/{id}` 删除
  - Controller：`NoteController.delete(id)`（需登录）。
  - Service：`NoteService.delete(userId,id)` → 作者校验 → `NoteMapper.deleteById(id)` → 失效 `evictHotAll/evictRecentAll`。

- `POST /api/notes/{id}/like` 点赞
  - Controller：`NoteController.like(id)`。
  - Service：`NoteService.like(userId,noteId)` → 可见性校验（私有仅作者）→ `NoteLikeMapper.insert(...)` → `MessageService.createLikeMessage(...)`（作者≠操作者）→ 失效 `evictHotAll` → 返回 `{count, likedByMe:true}`。

- `DELETE /api/notes/{id}/like` 取消点赞
  - Controller：`NoteController.unlike(id)`。
  - Service：`NoteService.unlike(userId,noteId)` → 可见性校验 → `NoteLikeMapper.delete(QueryWrapper...)` → 失效 `evictHotAll` → 返回 `{count, likedByMe:false}`。

- `POST /api/notes/{id}/favorite` 收藏
  - Controller：`NoteController.favorite(id)`。
  - Service：`NoteService.favorite(userId,noteId)` → 可见性校验 → `NoteFavoriteMapper.insert(...)`（组合唯一约束防重复）→ `MessageService.createFavoriteMessage(...)` → 失效 `evictHotAll` → 返回 `{count, favoritedByMe:true}`。

- `DELETE /api/notes/{id}/favorite` 取消收藏
  - Controller：`NoteController.unfavorite(id)`。
  - Service：`NoteService.unfavorite(userId,noteId)` → 可见性校验 → `NoteFavoriteMapper.delete(QueryWrapper...)` → 失效 `evictHotAll` → 返回 `{count, favoritedByMe:false}`。

- `GET /api/notes/public/recent?size=10` 最近公开
  - Controller：`NoteController.recent(size)`。
  - Service：`NoteService.recentPublic(userId,size)` → 读缓存 `noteCache.getRecent(size)`；未命中则 `NoteMapper.selectPage(...)`、聚合作者与计数 → 写缓存 `noteCache.setRecent(size, baseItems)` → 登录态补标记；返回 `Page<NoteItem>`。

- `GET /api/notes/public/hot?size=10` 热门公开
  - Controller：`NoteController.hot(size)`。
  - Service：`NoteService.hotPublic(userId,size)` → 读缓存 `noteCache.getHot(size)`；未命中则限定近 7 天集合、聚合与裁切 → 写缓存 → 登录态补标记；返回 `Page<NoteItem>`。

- `GET /api/notes/favorites` 我收藏的
  - Controller：`NoteController.listFavorited(page,size,q)`。
  - Service：`NoteService.listFavorited(userId,page,size,q)` → `FavoriteMapper.selectList(userId)` 得到 ids → `NoteMapper.selectPage(in ids...)` → 聚合作者与计数 → 登录态补标记 → 返回分页。

- `GET /api/notes/likes` 我点赞的
  - Controller：`NoteController.listLiked(page,size,q)`。
  - Service：`NoteService.listLiked(userId,page,size,q)` → 流程同上，将收藏改为点赞集合。

- `POST /api/notes/import` 批量导入
  - Controller：`NoteController.import(body)`。
  - Service：`NoteService.importNotes(userId, list)` → 逐条调用 `create(...)`，统计 `imported/failed` 与 `errors` → 返回汇总结构。

——

### 13.2 导航广场（Navigation）方法清单

- 分类列表（启用/全部/导出）
  - Controller：`NavigationController.categories/*`。
  - Service：`NavigationCategoryService.getRootCategories()` / `getAllEnabledCategories()` / `getAllCategories()` → `NavigationCategoryMapper` 读取并排序。

- 站点按分类分页
  - Controller：`GET /api/navigation/sites/category/{id}`。
  - Service：`NavigationSiteService.listByCategory(id,page,size)` → `NavigationSiteMapper.selectPage(QueryWrapper.eq("category_id",...))`，排序 `sort_order ASC, id ASC`。

- 站点标签搜索
  - Controller：`GET /api/navigation/sites/tags/{tags}`。
  - Service：`NavigationSiteService.searchSites(tags,page,size)` → 组合 LIKE 条件，分页返回。

- 导入/导出（分类/站点）
  - Controller：`POST /api/navigation/*/import` / `GET /api/navigation/*/export`。
  - Service：逐条查找/更新/创建，返回 `{"total","created","updated","errors"}`；导出为 CSV/JSON。

——

### 13.3 消息中心（Message）方法清单

- `GET /api/messages` 列表分页
  - Controller：`MessageController.list(page,size,type)` → 鉴权（未登录 401）。
  - Service：`MessageService.list(userId,page,size,type)` → `MessageMapper.selectPage(...)`，联表 `NoteMapper/UserMapper` 填充展示字段；返回分页结构。

- `POST /api/messages/{id}/read` 标记已读
  - Controller：`MessageController.read(id)`。
  - Service：`MessageService.markRead(userId,id)` → `MessageMapper.updateById(set is_read=true)`；仅归属者可操作。

- `DELETE /api/messages/{id}` 删除消息
  - Controller：`MessageController.delete(id)`。
  - Service：`MessageService.delete(userId,id)` → `MessageMapper.deleteById(id)`；仅归属者可操作。

- `GET /api/messages/counts` 未读计数
  - Controller：`MessageController.counts()`。
  - Service：`MessageService.counts(userId)` → `MessageMapper.countUnreadByUser(userId)` 并计算 `hasNew`。

- 行为消息创建（由拾言交互触发）
  - Service：`MessageService.createLikeMessage(actorUserId,noteId)` / `createFavoriteMessage(...)` → 若 `actorUserId==authorId` 则不创建；`MessageMapper.insert(...)` 写入。

——

### 13.4 账户与个人中心（Account）方法清单

- `GET /api/account/user?username=...` 查询公开资料
  - Controller：`AccountController.getUserPublic(username)` → 参数校验 → `UserMapper.selectOne(eq("username",u))` → 返回公开字段。

- 其他（模式说明）
  - `GET /api/account/me` 当前用户信息 → `UserMapper.selectById(uid)` → 过滤敏感字段。
  - `PUT /api/account/profile` 更新资料 → 校验当前用户 → `UserMapper.updateById`。
  - `POST /api/account/avatar` 头像上传 → 保存文件至 `uploads/avatars` → 更新 `avatarUrl`。

——

### 13.5 验证码与找回密码方法清单

- `POST /api/auth/forgot` 触发找回
  - Controller：`PasswordResetController.forgot(body)` → `CaptchaService.verify(captchaId,captchaCode)`；通过后 `PasswordResetService.createCode(email)` → 调用 `MailService` 发送邮件；异常转为 400/429。

- `POST /api/auth/reset` 重置密码
  - Controller：`PasswordResetController.reset(body)`。
  - Service：`PasswordResetService.resetWithCode(email,code,newPassword)` → 校验有效期/次数/频率 → `UserMapper.updateByEmail(... passwordHash=PasswordEncoder.encode(newPassword))`。

- 验证码生成/校验
  - Controller：`CaptchaController.*`。
  - Service：`CaptchaService.create(sessionId)` / `verify(captchaId,code)` → 存取验证码（建议 Redis + TTL），校验匹配并限流。

——

### 13.6 管理后台（Admin）方法清单

- `GET /api/admin/users` 用户分页
  - Controller：`AdminController.listUsers(page,size,q)` → `@PreAuthorize('hasRole('ADMIN')')`。
  - Service/Mapper：`UserMapper.selectPage(QueryWrapper.like(username/nickname/email).orderByDesc("id"))` → 映射为 `UserSummary`（不暴露密码哈希）。

- `PUT /api/admin/users/{id}` 更新用户
  - Controller：`AdminController.updateUser(id,body)` → 方法级鉴权 + 事务。
  - Service/Mapper：根据入参更新字段；若包含明文密码 → `PasswordEncoder.encode(password)` → `UserMapper.updateById(u)`。

- 日志分页与导出
  - Controller：`AdminController.logs/*` 与 `logs/*/export`。
  - Service/Mapper：对应 `AuditLogMapper/RequestLogMapper/AuthLogMapper/ErrorLogMapper` 的 `selectPage` 与导出查询；返回 CSV/JSON 二进制流。

——

附注：以上清单仅列出代码库中已实现的端点与方法；若需对每个方法补充“参数校验细则、异常翻译、缓存键空间与 TTL 策略、并发控制与幂等约束”的逐行说明，我可以继续迭代并在相关源码注释块中补充细节，确保维护友好与一致性。
## 验证码与找回密码（优化版）

本节在原有“验证码与找回密码”描述基础上，补充并固化了后端已实施的安全与易用性优化，明确接口参数、流程、返回与风控策略。

- 接口与参数
  - `POST /api/auth/forgot`
    - `email`：接收验证码的邮箱（必填；基础格式校验）。
    - `captchaId`：图形验证码会话 ID（必填）。
    - `captchaCode`：图形验证码文本（必填）。
  - `POST /api/auth/reset`
    - `email`：账户邮箱（必填）。
    - `code`：邮箱验证码（6 位数字，必填）。
    - `newPassword`：新密码（必填；至少 8 位，需包含大小写字母与数字）。

- 控制器行为摘要
  - 触发找回 `forgot`
    - 先通过图形验证码校验（失败返回 `400`）。
    - 对 `email` 做基础格式校验（失败返回 `400`）。
    - 静默存在性检查：邮箱不存在时不发送验证码，但统一返回 `{ ok: true }`，避免用户枚举风险。
    - 若邮箱存在且未触达频率限制，调用服务生成一次性验证码并发送邮件；否则返回 `429`。
  - 执行重置 `reset`
    - 对 `newPassword` 做强度校验：至少 8 位，包含大小写与数字（失败返回 `400`）。
    - 校验邮箱验证码（格式、有效期、失败次数超限），失败返回 `400`。
    - 验证通过后更新密码哈希；邮箱不存在返回 `400`；成功返回 `{ ok: true }`。

- 服务层实现要点（PasswordResetService）
  - 验证码生成与发送：默认 6 位数字；有效期默认 5 分钟（配置 `password-reset.code-ttl-seconds` 可改）；调用 `MailService#sendBindEmailCode` 发送。
  - 发送频率限制：同一邮箱 60 秒内不重复、每小时最多 5 次（内存窗口，生产建议迁移到 Redis 或统一风控中间件）。
  - 校验与失败次数：
    - 校验时先进行格式检查（仅数字且长度匹配）。
    - 验证失败将累计错误次数，达到阈值（默认 5 次，可配 `password-reset.max-verify-attempts`）后直接作废验证码，防止暴力尝试。
    - 成功后立即作废，避免重放。
  - 可配置项（已支持）：
    - `password-reset.code-ttl-seconds`（默认 `300`）
    - `password-reset.max-verify-attempts`（默认 `5`）
    - `password-reset.code-length`（默认 `6`）

- 输入校验与错误消息
  - 图形验证码错误：`400 { ok:false, message:"验证码错误" }`
  - 邮箱格式错误：`400 { ok:false, message:"邮箱格式不正确" }`
  - 邮件发送过于频繁：`429 { ok:false, message:<提示> }`
  - 邮箱验证码错误/过期/失败次数超限：`400 { ok:false, message:"验证码无效或已过期" }`
  - 邮箱不存在（重置时）：`400 { ok:false, message:"邮箱不存在" }`

- 前端交互建议
  - 找回流程：输入邮箱 + 图形验证码 → 触发 `forgot` → 邮箱查收 6 位验证码。
  - 重置流程：填写邮箱 + 邮箱验证码 + 新密码（符合强度）→ 调用 `reset` → 成功后提示重新登录。
  - 错误态统一提示文案，避免暴露用户是否存在；对于 `429` 情况提示稍后重试。

- 后续可演进方向（推荐）
  - 将验证码存储与频率限制迁移至 Redis：使用键空间 `pwdreset:code:{email}`，TTL 同配置；失败次数计数键 `pwdreset:fail:{email}`。
  - 增加设备/请求指纹维度的限流，结合认证日志做风控告警。
  - 新密码强度策略可提升为 zxcvbn 评分或更完善的规则；后端使用统一校验器复用到注册与修改密码流程。